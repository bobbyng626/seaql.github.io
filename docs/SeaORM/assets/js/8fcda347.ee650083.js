(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[6113],{3905:function(e,t,r){"use strict";r.d(t,{Zo:function(){return u},kt:function(){return p}});var a=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=i,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||n;return r?a.createElement(m,o(o({ref:t},u),{},{components:r})):a.createElement(m,o({ref:t},u))}));function p(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,o=new Array(n);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<n;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},8950:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var a=r(2122),i=r(9756),n=(r(7294),r(3905)),o=["components"],s={},l="Compare with Diesel",c={unversionedId:"internal-design/diesel",id:"internal-design/diesel",isDocsHomePage:!1,title:"Compare with Diesel",description:"SeaORM and Diesel shares the same goal: to offer you a complete solution in interfacing with databases.",source:"@site/docs/08-internal-design/03-diesel.md",sourceDirName:"08-internal-design",slug:"/internal-design/diesel",permalink:"/SeaORM/docs/internal-design/diesel",editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/08-internal-design/03-diesel.md",version:"current",lastUpdatedBy:"Chris Tsang",lastUpdatedAt:1627661403,formattedLastUpdatedAt:"7/31/2021",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Derive Macros",permalink:"/SeaORM/docs/internal-design/derive-macro"}},u=[{value:"Architecture",id:"architecture",children:[]},{value:"Programming paradigm",id:"programming-paradigm",children:[]},{value:"Schema Builder",id:"schema-builder",children:[]},{value:"Similarities",id:"similarities",children:[]},{value:"Final words",id:"final-words",children:[]}],d={toc:u};function h(e){var t=e.components,r=(0,i.Z)(e,o);return(0,n.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"compare-with-diesel"},"Compare with Diesel"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/sea-orm"},"SeaORM")," and ",(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/diesel"},"Diesel")," shares the same goal: to offer you a complete solution in interfacing with databases."),(0,n.kt)("p",null,"Both SeaORM and Diesel works with MySQL, Postgres and SQLite, so you aren't constrained going with either."),(0,n.kt)("p",null,"However, there are things we chose to do differently."),(0,n.kt)("h2",{id:"architecture"},"Architecture"),(0,n.kt)("p",null,"First off, perhaps the number one requested feature, async Rust support. While using async may not offer you better performance today, programming in async is an architectural decision you have to make early on. By choosing SeaORM, we together look forward to Rust's async ecosystem maturing."),(0,n.kt)("p",null,"Under the hood, SeaORM together with ",(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/sqlx"},"SQLx")," offers you a pure Rust technology stack. While Diesel is tied to native drivers. Each side has their pros and cons, so it's up to your preference."),(0,n.kt)("p",null,"SeaORM has a modular design. If you don't like the idea of ORM, you'll definitely still want to use ",(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/sea-query"},"SeaQuery"),", the underlying query builder. It is light weight and can be easily integrated into any project. The SeaQuery API is also available to you when using SeaORM, so you receive the benefits of high level abstraction while still having the power of a flexible query builder when you need it."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/sea-schema"},"SeaSchema")," is our schema management utility, but it is not sealed inside SeaORM. You can use SeaSchema to manage schema and generate models for other ORMs."),(0,n.kt)("h2",{id:"programming-paradigm"},"Programming paradigm"),(0,n.kt)("p",null,"In addition to the sync vs async foundation, the biggest distinction between Diesel and SeaORM is static vs dynamic. Diesel has an everything-compile-time design which has its pros and cons. SeaORM is dynamic, in which things are established runtime. It offers more flexibility. While you loses some compile-time guarantee, SeaORM helps you to prove correctness by unit testing instead."),(0,n.kt)("p",null,"Both libraries make heavy use of traits and generics, but SeaORM generate less types (each column in Diesel is a struct, while each column in SeaORM is a enum variant) and less depthness (there won't be ",(0,n.kt)("inlineCode",{parentName:"p"},"A<B<C<D>>>"),"). That probably means looser type/lifetime constraints and faster compilation."),(0,n.kt)("p",null,"We keep macros out of the API of SeaORM. We provide some derive macros for implementing traits, but it is possible to use SeaORM without macros."),(0,n.kt)("h2",{id:"schema-builder"},"Schema Builder"),(0,n.kt)("p",null,"While in the Diesel ecosystem there are awesome libraries like ",(0,n.kt)("a",{parentName:"p",href:"https://crates.io/crates/barrel"},"barrel"),", SeaQL maintain the tools for schema building and management. That means a familiar API and a unified experience."),(0,n.kt)("h2",{id:"similarities"},"Similarities"),(0,n.kt)("p",null,"Both Diesel and SeaORM are schema first, meaning it all starts from your existing database schema, instead of starting from your OOP classes."),(0,n.kt)("p",null,"Both Diesel and SeaORM are relational, meaning you can do complex joins with defined relations."),(0,n.kt)("h2",{id:"final-words"},"Final words"),(0,n.kt)("p",null,"Diesel is a well established library in the Rust ecosystem. SeaORM is very new. Neither can replace the other. We hope that the Rust community will grow stronger together."))}h.isMDXComponent=!0}}]);